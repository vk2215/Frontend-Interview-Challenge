# Frontend Challenge Submission

**Candidate Name:** Vaishnavi Kale
**Date:** 16th October 2025
**Time Spent:** 4-5 hours


---

## ‚úÖ Completed Features

Mark which features you completed:

### Core Features
- [x] Day View calendar (time slots 8 AM - 6 PM)
- [x] Week View calendar (7-day grid)
- [x] Doctor selector dropdown
- [x] Appointment rendering with correct positioning
- [x] Color-coding by appointment type
- [x] Service layer implementation
- [x] Custom hooks (headless pattern)
- [x] Component composition

### Bonus Features (if any)
- [x] Current time indicator
- [x] Responsive design (mobile-friendly)
- [x] Empty states
- [x] Loading states
- [x] Error handling
- [x] Appointment search/filter
- [x] Dark mode
- [x] Accessibility improvements
- [ ] Other: _________________

---

### State Management

**What state management approach did you use?**
- [ ] useState + useEffect only
- [x] Custom hooks (headless pattern)
- [ ] React Context
- [ ] External library (Redux, Zustand, etc.)
- [ ] Other: _________________

**Why did you choose this approach?**

The **Custom Hook** approach is the best fit for managing localized data fetching, loading, and error concerns. The `useAppointments` hook centralizes the entire data flow for the scheduler, keeping the main component tree clean and allowing easy injection of business logic without relying on heavy external libraries for local state.

---

### Service Layer

**How did you structure your data access?**

I used an ES6 **Class** (`AppointmentService`) exposed as a **singleton instance**. This creates a clear, abstract boundary between the UI logic and the data source (mock data), fulfilling the Service Layer requirement.

**What methods did you implement in AppointmentService?**

- [x] getAppointmentsByDoctor
- [x] getAppointmentsByDoctorAndDate
- [x] getAppointmentsByDoctorAndDateRange
- [x] getPopulatedAppointment
- [x] getAllDoctors
- [x] Other: `sortAppointmentsByTime` (Helper to ensure appointments display in chronological order)

---

### Custom Hooks

**What custom hooks did you create?**

1. `useAppointments` - **Core Logic.** Fetches and filters appointments based on the provided doctor and date/date range, manages `loading` and `error` states, and returns the processed data.
2. `useDoctors` - Fetches the complete list of doctor models for the selector component.

**How do they demonstrate the headless pattern?**

They are "headless" because they contain all the logic for *what* data to fetch and *how* to process it (filtering, sorting, error handling) without rendering any HTML. The component only consumes the structured output of the hook.

---

## üé® UI/UX Decisions

### Calendar Rendering

**How did you generate time slots?**

Time slots (30-minute intervals from 8 AM to 6 PM) are generated by iterating from hour 8 to 18 within a `useMemo` call in the Day/Week view components.

**How did you position appointments in time slots?**

For the **Day View**, appointments are positioned using **CSS absolute positioning**. The `top` and `height` properties are calculated in pixels based on the appointment's start time and duration relative to the calendar's 8:00 AM baseline.

**How did you handle overlapping appointments?**

I implemented a **Greedy Column Packing Algorithm**. This algorithm detects concurrency, assigns a column index to each conflicting appointment, and calculates the necessary `left` position and `width` (as percentages) to stack the appointments side-by-side, preventing overlaps.

---

### Responsive Design

**Is your calendar mobile-friendly?**
- [x] Yes, fully responsive
- [ ] Partially (some responsive elements)
- [ ] No (desktop only)

**What responsive strategies did you use?**

The **Week View** utilizes an `overflow-x-auto` wrapper on the main table, allowing horizontal scrolling to view the 7 days on mobile screens while keeping the time column sticky. The **Day View** uses fluid, percentage-based positioning logic for appointments, ensuring they scale correctly on smaller widths.

---

## üß™ Testing & Quality

### Code Quality

**Did you run these checks?**
- [x] `npm run lint` - No errors
- [x] `npm run type-check` - No TypeScript errors
- [x] `npm run build` - Builds successfully
- [x] Manual testing - All features work

### Testing Approach

**Did you write any tests?**
- [ ] Yes (describe below)
- [x] No (ran out of time)

---
## üöÄ Future Improvements

What would you add/improve given more time?

1.  **Virtualization:** Implement virtualization (e.g., `react-window`) on the calendar views to ensure smooth performance with potentially thousands of appointments.
2.  **API Integration:** Convert all `AppointmentService` methods to be `async` and introduce a client-side data cache (like React Query/TanStack Query) for a production-ready data flow.
3.  **Refactor Overlap Logic:** Extract the positioning logic from `DayView.tsx` into a dedicated custom hook for better modularity and test isolation.

---

## üí≠ Challenges & Learnings

**Biggest Challenge:**  
- Rendering overlapping appointments in week view clearly  

**What I Learned:**  
- Separation of logic from UI using headless hooks  
- Efficient use of CSS Grid + Flexbox for complex calendar layouts  
- TypeScript type-safe rendering  

**Most Proud Of:**  
- Clean, reusable component architecture  
- Fully functional Day and Week views with proper color coding  

---

## üéØ Trade-offs

**Time vs. Features:**  
- Focused on **full Day & Week views, service layer, responsive design**  
- Deferred some optional features like advanced search and animations  

**Technical Trade-offs:**  
- Used simple array filters for appointment lookup for simplicity  
- No drag-and-drop to meet deadline constraints  

---

**Where did you spend most of your time?**

- [x] Architecture/planning
- [x] Day view implementation (overlap logic)
- [ ] Week view implementation
- [ ] Styling/polish
- [ ] Refactoring
- [ ] Other: _________________

**What did you prioritize and why?**

I prioritized **Architecture and the Day View's core rendering functionality**. A strong architectural foundation and solving the most complex rendering problem (overlap handling) were deemed more valuable than comprehensive styling or writing tests.

---

## üìö Libraries & Tools Used

### Third-Party Libraries
Did you use any additional libraries beyond what was provided?

**Calendar/UI Libraries:**
- [ ] react-big-calendar
- [ ] FullCalendar
- [ ] shadcn/ui
- [ ] Radix UI
- [ ] Headless UI
- [x] Other: **Tailwind CSS** (for styling and utility classes)

**Utility Libraries:**
- [ ] lodash
- [ ] ramda
- [x] Other: **date-fns** (for time utilities)

**Why did you choose these libraries?**

Tailwind CSS provides rapid, utility-first styling for quickly achieving the UI requirements. `date-fns` is a lightweight, tree-shakeable library crucial for robust date comparisons and manipulation within the service layer.

---

### AI Tools & Documentation

**AI Coding Assistants:**
- [x] GitHub Copilot
- [x] ChatGPT
- [ ] Claude
- [ ] Other: _________________

**How did you use AI tools?**

I used AI tools for:
* **Boilerplate and Structure:** Generating initial component and hook structure skeletons.
* **Algorithmic Inspiration:** Validating and refining the mathematical approach for the Day View's **overlap detection** algorithm.
* **Tailwind:** Generating utility class combinations for complex layouts and responsive design.

The generated code was always reviewed, understood, and integrated/modified to adhere to the strict architectural boundaries.

**Documentation & Resources:**
- [x] React documentation
- [x] Next.js documentation
- [x] date-fns documentation
- [x] TypeScript documentation
- [x] Tailwind CSS documentation
- [ ] Library-specific documentation
- [x] Stack Overflow / GitHub Issues

---

## üìù Additional Notes

The solution successfully separates the data access layer (`AppointmentService`) from the state logic (`useAppointments`), providing a clean, scalable foundation ready for integration with a real, asynchronous backend API.